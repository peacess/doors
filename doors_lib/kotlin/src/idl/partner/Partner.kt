// automatically generated by the FlatBuffers compiler, do not modify

package partner

import com.google.flatbuffers.kotlin.*
import kotlin.jvm.JvmInline
@Suppress("unused")
class Partner : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : Partner = reset(i, buffer)

    val id : base.UlidBytes? get() = id(base.UlidBytes())
    fun id(obj: base.UlidBytes) : base.UlidBytes? = lookupField(4, null ) { obj.init(it + bufferPos, bb) }

    fun terminalIds(j: Int) : base.TerminalId? = terminalIds(base.TerminalId(), j)
    fun terminalIds(obj: base.TerminalId, j: Int) : base.TerminalId? = lookupField(6, null ) { obj.init(vector(it) + j * 16, bb) }
    val terminalIdsLength : Int get() = lookupField(6, 0 ) { vectorLength(it) }

    val partnerId : base.UByte16? get() = partnerId(base.UByte16())
    fun partnerId(obj: base.UByte16) : base.UByte16? = lookupField(8, null ) { obj.init(it + bufferPos, bb) }

    val name : String? get() = lookupField(10, null ) { string(it + bufferPos) }
    fun nameAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 10, 1)

    val showName : String? get() = lookupField(12, null ) { string(it + bufferPos) }
    fun showNameAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 12, 1)

    val ip : String? get() = lookupField(14, null ) { string(it + bufferPos) }
    fun ipAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 14, 1)

    val port : Short get() = lookupField(16, 0 ) { bb.getShort(it + bufferPos) }

    val createTs : base.Timestamp? get() = createTs(base.Timestamp())
    fun createTs(obj: base.Timestamp) : base.Timestamp? = lookupField(18, null ) { obj.init(it + bufferPos, bb) }

    companion object {
        @JvmStatic
        fun validateVersion() = VERSION_2_0_8

        @JvmStatic
        fun asRoot(buffer: ReadWriteBuffer) : Partner = asRoot(buffer, Partner())
        @JvmStatic
        fun asRoot(buffer: ReadWriteBuffer, obj: Partner) : Partner = obj.init(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        @JvmStatic
        fun startPartner(builder: FlatBufferBuilder) = builder.startTable(8)

        @JvmStatic
        fun addId(builder: FlatBufferBuilder, id: Offset<base.UlidBytes>) = builder.addStruct(0, id.value, 0)

        @JvmStatic
        fun addTerminalIds(builder: FlatBufferBuilder, terminalIds: VectorOffset<base.TerminalId>) = builder.add(1, terminalIds, 0)

        @JvmStatic
        fun startTerminalIdsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(16, numElems, 8)

        @JvmStatic
        fun addPartnerId(builder: FlatBufferBuilder, partnerId: Offset<base.UByte16>) = builder.addStruct(2, partnerId.value, 0)

        @JvmStatic
        fun addName(builder: FlatBufferBuilder, name: Offset<String>) = builder.add(3, name, 0)

        @JvmStatic
        fun addShowName(builder: FlatBufferBuilder, showName: Offset<String>) = builder.add(4, showName, 0)

        @JvmStatic
        fun addIp(builder: FlatBufferBuilder, ip: Offset<String>) = builder.add(5, ip, 0)

        @JvmStatic
        fun addPort(builder: FlatBufferBuilder, port: Short) = builder.add(6, port, 0)

        @JvmStatic
        fun addCreateTs(builder: FlatBufferBuilder, createTs: Offset<base.Timestamp>) = builder.addStruct(7, createTs.value, 0)

        @JvmStatic
        fun endPartner(builder: FlatBufferBuilder) : Offset<Partner> {
            val o: Offset<Partner> = builder.endTable()
            return o
        }

        @JvmStatic
        fun finishPartnerBuffer(builder: FlatBufferBuilder, offset: Offset<Partner>) = builder.finish(offset)

        @JvmStatic
        fun finishSizePrefixedPartnerBuffer(builder: FlatBufferBuilder, offset: Offset<Partner>) = builder.finishSizePrefixed(offset)
    }
}

typealias PartnerOffsetArray = OffsetArray<Partner>

inline fun PartnerOffsetArray(size: Int, crossinline call: (Int) -> Offset<Partner>): PartnerOffsetArray =
    PartnerOffsetArray(IntArray(size) { call(it).value })
