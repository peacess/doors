// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::{cmp::Ordering, mem};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod base {

    use core::{cmp::Ordering, mem};

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    // struct UlidBytes, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct UlidBytes(pub [u8; 16]);
    impl Default for UlidBytes {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for UlidBytes {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("UlidBytes").field("low", &self.low()).field("high", &self.high()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UlidBytes {}
    impl<'a> flatbuffers::Follow<'a> for UlidBytes {
        type Inner = &'a UlidBytes;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a UlidBytes>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a UlidBytes {
        type Inner = &'a UlidBytes;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<UlidBytes>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for UlidBytes {
        type Output = UlidBytes;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const UlidBytes as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for UlidBytes {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> UlidBytes {
        #[allow(clippy::too_many_arguments)]
        pub fn new(low: u64, high: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_low(low);
            s.set_high(high);
            s
        }

        pub fn low(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_low(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn high(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_high(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> UlidBytesT {
            UlidBytesT {
                low: self.low(),
                high: self.high(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct UlidBytesT {
        pub low: u64,
        pub high: u64,
    }
    impl UlidBytesT {
        pub fn pack(&self) -> UlidBytes {
            UlidBytes::new(self.low, self.high)
        }
    }

    // struct UuidV7Bytes, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct UuidV7Bytes(pub [u8; 16]);
    impl Default for UuidV7Bytes {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for UuidV7Bytes {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("UuidV7Bytes").field("low", &self.low()).field("high", &self.high()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UuidV7Bytes {}
    impl<'a> flatbuffers::Follow<'a> for UuidV7Bytes {
        type Inner = &'a UuidV7Bytes;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a UuidV7Bytes>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a UuidV7Bytes {
        type Inner = &'a UuidV7Bytes;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<UuidV7Bytes>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for UuidV7Bytes {
        type Output = UuidV7Bytes;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const UuidV7Bytes as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for UuidV7Bytes {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> UuidV7Bytes {
        #[allow(clippy::too_many_arguments)]
        pub fn new(low: u64, high: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_low(low);
            s.set_high(high);
            s
        }

        pub fn low(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_low(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn high(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_high(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> UuidV7BytesT {
            UuidV7BytesT {
                low: self.low(),
                high: self.high(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct UuidV7BytesT {
        pub low: u64,
        pub high: u64,
    }
    impl UuidV7BytesT {
        pub fn pack(&self) -> UuidV7Bytes {
            UuidV7Bytes::new(self.low, self.high)
        }
    }

    // struct Ipv6, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Ipv6(pub [u8; 16]);
    impl Default for Ipv6 {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for Ipv6 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Ipv6")
                .field("ub1", &self.ub1())
                .field("ub2", &self.ub2())
                .field("ub3", &self.ub3())
                .field("ub4", &self.ub4())
                .field("ub5", &self.ub5())
                .field("ub6", &self.ub6())
                .field("ub7", &self.ub7())
                .field("ub8", &self.ub8())
                .field("ub9", &self.ub9())
                .field("ub10", &self.ub10())
                .field("ub11", &self.ub11())
                .field("ub12", &self.ub12())
                .field("ub13", &self.ub13())
                .field("ub14", &self.ub14())
                .field("ub15", &self.ub15())
                .field("ub16", &self.ub16())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Ipv6 {}
    impl<'a> flatbuffers::Follow<'a> for Ipv6 {
        type Inner = &'a Ipv6;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a Ipv6>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Ipv6 {
        type Inner = &'a Ipv6;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<Ipv6>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for Ipv6 {
        type Output = Ipv6;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const Ipv6 as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for Ipv6 {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Ipv6 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(
            ub1: u8,
            ub2: u8,
            ub3: u8,
            ub4: u8,
            ub5: u8,
            ub6: u8,
            ub7: u8,
            ub8: u8,
            ub9: u8,
            ub10: u8,
            ub11: u8,
            ub12: u8,
            ub13: u8,
            ub14: u8,
            ub15: u8,
            ub16: u8,
        ) -> Self {
            let mut s = Self([0; 16]);
            s.set_ub1(ub1);
            s.set_ub2(ub2);
            s.set_ub3(ub3);
            s.set_ub4(ub4);
            s.set_ub5(ub5);
            s.set_ub6(ub6);
            s.set_ub7(ub7);
            s.set_ub8(ub8);
            s.set_ub9(ub9);
            s.set_ub10(ub10);
            s.set_ub11(ub11);
            s.set_ub12(ub12);
            s.set_ub13(ub13);
            s.set_ub14(ub14);
            s.set_ub15(ub15);
            s.set_ub16(ub16);
            s
        }

        pub fn ub1(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub1(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub2(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[1..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub2(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[1..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub3(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[2..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub3(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[2..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub4(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[3..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub4(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[3..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub5(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub5(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub6(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[5..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub6(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[5..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub7(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[6..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub7(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[6..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub8(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[7..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub8(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[7..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub9(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub9(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub10(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[9..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub10(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[9..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub11(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[10..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub11(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[10..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub12(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[11..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub12(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[11..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub13(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[12..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub13(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[12..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub14(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[13..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub14(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[13..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub15(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[14..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub15(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[14..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub16(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[15..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub16(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[15..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> Ipv6T {
            Ipv6T {
                ub1: self.ub1(),
                ub2: self.ub2(),
                ub3: self.ub3(),
                ub4: self.ub4(),
                ub5: self.ub5(),
                ub6: self.ub6(),
                ub7: self.ub7(),
                ub8: self.ub8(),
                ub9: self.ub9(),
                ub10: self.ub10(),
                ub11: self.ub11(),
                ub12: self.ub12(),
                ub13: self.ub13(),
                ub14: self.ub14(),
                ub15: self.ub15(),
                ub16: self.ub16(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct Ipv6T {
        pub ub1: u8,
        pub ub2: u8,
        pub ub3: u8,
        pub ub4: u8,
        pub ub5: u8,
        pub ub6: u8,
        pub ub7: u8,
        pub ub8: u8,
        pub ub9: u8,
        pub ub10: u8,
        pub ub11: u8,
        pub ub12: u8,
        pub ub13: u8,
        pub ub14: u8,
        pub ub15: u8,
        pub ub16: u8,
    }
    impl Ipv6T {
        pub fn pack(&self) -> Ipv6 {
            Ipv6::new(
                self.ub1, self.ub2, self.ub3, self.ub4, self.ub5, self.ub6, self.ub7, self.ub8, self.ub9, self.ub10, self.ub11, self.ub12, self.ub13,
                self.ub14, self.ub15, self.ub16,
            )
        }
    }

    // struct X25519Public, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct X25519Public(pub [u8; 32]);
    impl Default for X25519Public {
        fn default() -> Self {
            Self([0; 32])
        }
    }
    impl core::fmt::Debug for X25519Public {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("X25519Public")
                .field("key1", &self.key1())
                .field("key2", &self.key2())
                .field("key3", &self.key3())
                .field("key4", &self.key4())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for X25519Public {}
    impl<'a> flatbuffers::Follow<'a> for X25519Public {
        type Inner = &'a X25519Public;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a X25519Public>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a X25519Public {
        type Inner = &'a X25519Public;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<X25519Public>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for X25519Public {
        type Output = X25519Public;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const X25519Public as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for X25519Public {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> X25519Public {
        #[allow(clippy::too_many_arguments)]
        pub fn new(key1: u64, key2: u64, key3: u64, key4: u64) -> Self {
            let mut s = Self([0; 32]);
            s.set_key1(key1);
            s.set_key2(key2);
            s.set_key3(key3);
            s.set_key4(key4);
            s
        }

        pub fn key1(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_key1(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn key2(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_key2(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn key3(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[16..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_key3(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[16..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn key4(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[24..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_key4(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[24..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> X25519PublicT {
            X25519PublicT {
                key1: self.key1(),
                key2: self.key2(),
                key3: self.key3(),
                key4: self.key4(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct X25519PublicT {
        pub key1: u64,
        pub key2: u64,
        pub key3: u64,
        pub key4: u64,
    }
    impl X25519PublicT {
        pub fn pack(&self) -> X25519Public {
            X25519Public::new(self.key1, self.key2, self.key3, self.key4)
        }
    }

    // struct Uint128, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Uint128(pub [u8; 16]);
    impl Default for Uint128 {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for Uint128 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Uint128").field("low", &self.low()).field("high", &self.high()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Uint128 {}
    impl<'a> flatbuffers::Follow<'a> for Uint128 {
        type Inner = &'a Uint128;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a Uint128>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Uint128 {
        type Inner = &'a Uint128;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<Uint128>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for Uint128 {
        type Output = Uint128;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const Uint128 as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for Uint128 {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Uint128 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(low: u64, high: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_low(low);
            s.set_high(high);
            s
        }

        pub fn low(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_low(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn high(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_high(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> Uint128T {
            Uint128T {
                low: self.low(),
                high: self.high(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct Uint128T {
        pub low: u64,
        pub high: u64,
    }
    impl Uint128T {
        pub fn pack(&self) -> Uint128 {
            Uint128::new(self.low, self.high)
        }
    }

    // struct PartnerId, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct PartnerId(pub [u8; 16]);
    impl Default for PartnerId {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for PartnerId {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("PartnerId").field("low", &self.low()).field("high", &self.high()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for PartnerId {}
    impl<'a> flatbuffers::Follow<'a> for PartnerId {
        type Inner = &'a PartnerId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a PartnerId>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a PartnerId {
        type Inner = &'a PartnerId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<PartnerId>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for PartnerId {
        type Output = PartnerId;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const PartnerId as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for PartnerId {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> PartnerId {
        #[allow(clippy::too_many_arguments)]
        pub fn new(low: u64, high: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_low(low);
            s.set_high(high);
            s
        }

        pub fn low(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_low(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn high(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_high(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> PartnerIdT {
            PartnerIdT {
                low: self.low(),
                high: self.high(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct PartnerIdT {
        pub low: u64,
        pub high: u64,
    }
    impl PartnerIdT {
        pub fn pack(&self) -> PartnerId {
            PartnerId::new(self.low, self.high)
        }
    }

    // struct TerminalId, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct TerminalId(pub [u8; 16]);
    impl Default for TerminalId {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for TerminalId {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("TerminalId").field("low", &self.low()).field("high", &self.high()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TerminalId {}
    impl<'a> flatbuffers::Follow<'a> for TerminalId {
        type Inner = &'a TerminalId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a TerminalId>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a TerminalId {
        type Inner = &'a TerminalId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<TerminalId>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for TerminalId {
        type Output = TerminalId;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const TerminalId as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for TerminalId {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> TerminalId {
        #[allow(clippy::too_many_arguments)]
        pub fn new(low: u64, high: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_low(low);
            s.set_high(high);
            s
        }

        pub fn low(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_low(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn high(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_high(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> TerminalIdT {
            TerminalIdT {
                low: self.low(),
                high: self.high(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct TerminalIdT {
        pub low: u64,
        pub high: u64,
    }
    impl TerminalIdT {
        pub fn pack(&self) -> TerminalId {
            TerminalId::new(self.low, self.high)
        }
    }

    // struct Timestamp, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Timestamp(pub [u8; 8]);
    impl Default for Timestamp {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for Timestamp {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Timestamp").field("ts", &self.ts()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Timestamp {}
    impl<'a> flatbuffers::Follow<'a> for Timestamp {
        type Inner = &'a Timestamp;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a Timestamp>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
        type Inner = &'a Timestamp;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<Timestamp>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for Timestamp {
        type Output = Timestamp;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const Timestamp as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for Timestamp {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Timestamp {
        #[allow(clippy::too_many_arguments)]
        pub fn new(ts: i64) -> Self {
            let mut s = Self([0; 8]);
            s.set_ts(ts);
            s
        }

        pub fn ts(&self) -> i64 {
            let mut mem = core::mem::MaybeUninit::<<i64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<i64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ts(&mut self, x: i64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<i64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> TimestampT {
            TimestampT { ts: self.ts() }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct TimestampT {
        pub ts: i64,
    }
    impl TimestampT {
        pub fn pack(&self) -> Timestamp {
            Timestamp::new(self.ts)
        }
    }

    // struct Header, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Header(pub [u8; 64]);
    impl Default for Header {
        fn default() -> Self {
            Self([0; 64])
        }
    }
    impl core::fmt::Debug for Header {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Header")
                .field("len", &self.len())
                .field("header_type", &self.header_type())
                .field("frame_type", &self.frame_type())
                .field("to_terminal_id", &self.to_terminal_id())
                .field("key", &self.key())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Header {}
    impl<'a> flatbuffers::Follow<'a> for Header {
        type Inner = &'a Header;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a Header>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Header {
        type Inner = &'a Header;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<Header>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for Header {
        type Output = Header;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const Header as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for Header {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Header {
        #[allow(clippy::too_many_arguments)]
        pub fn new(len: u64, header_type: u32, frame_type: u32, to_terminal_id: &TerminalId, key: &X25519Public) -> Self {
            let mut s = Self([0; 64]);
            s.set_len(len);
            s.set_header_type(header_type);
            s.set_frame_type(frame_type);
            s.set_to_terminal_id(to_terminal_id);
            s.set_key(key);
            s
        }

        pub fn len(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_len(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn header_type(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_header_type(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn frame_type(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[12..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_frame_type(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[12..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn to_terminal_id(&self) -> &TerminalId {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[16..].as_ptr() as *const TerminalId) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_to_terminal_id(&mut self, x: &TerminalId) {
            self.0[16..16 + 16].copy_from_slice(&x.0)
        }

        pub fn key(&self) -> &X25519Public {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[32..].as_ptr() as *const X25519Public) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_key(&mut self, x: &X25519Public) {
            self.0[32..32 + 32].copy_from_slice(&x.0)
        }

        pub fn unpack(&self) -> HeaderT {
            HeaderT {
                len: self.len(),
                header_type: self.header_type(),
                frame_type: self.frame_type(),
                to_terminal_id: self.to_terminal_id().unpack(),
                key: self.key().unpack(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct HeaderT {
        pub len: u64,
        pub header_type: u32,
        pub frame_type: u32,
        pub to_terminal_id: TerminalIdT,
        pub key: X25519PublicT,
    }
    impl HeaderT {
        pub fn pack(&self) -> Header {
            Header::new(self.len, self.header_type, self.frame_type, &self.to_terminal_id.pack(), &self.key.pack())
        }
    }

    // struct FrameConfirm, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct FrameConfirm(pub [u8; 32]);
    impl Default for FrameConfirm {
        fn default() -> Self {
            Self([0; 32])
        }
    }
    impl core::fmt::Debug for FrameConfirm {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("FrameConfirm")
                .field("id", &self.id())
                .field("frame_id", &self.frame_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for FrameConfirm {}
    impl<'a> flatbuffers::Follow<'a> for FrameConfirm {
        type Inner = &'a FrameConfirm;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { <&'a FrameConfirm>::follow(buf, loc) }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a FrameConfirm {
        type Inner = &'a FrameConfirm;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            unsafe { flatbuffers::follow_cast_ref::<FrameConfirm>(buf, loc) }
        }
    }
    impl<'b> flatbuffers::Push for FrameConfirm {
        type Output = FrameConfirm;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = unsafe { ::core::slice::from_raw_parts(self as *const FrameConfirm as *const u8, <Self as flatbuffers::Push>::size()) };
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for FrameConfirm {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> FrameConfirm {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: &UlidBytes, frame_id: &UlidBytes) -> Self {
            let mut s = Self([0; 32]);
            s.set_id(id);
            s.set_frame_id(frame_id);
            s
        }

        pub fn id(&self) -> &UlidBytes {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[0..].as_ptr() as *const UlidBytes) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_id(&mut self, x: &UlidBytes) {
            self.0[0..0 + 16].copy_from_slice(&x.0)
        }

        pub fn frame_id(&self) -> &UlidBytes {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[16..].as_ptr() as *const UlidBytes) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_frame_id(&mut self, x: &UlidBytes) {
            self.0[16..16 + 16].copy_from_slice(&x.0)
        }

        pub fn unpack(&self) -> FrameConfirmT {
            FrameConfirmT {
                id: self.id().unpack(),
                frame_id: self.frame_id().unpack(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct FrameConfirmT {
        pub id: UlidBytesT,
        pub frame_id: UlidBytesT,
    }
    impl FrameConfirmT {
        pub fn pack(&self) -> FrameConfirm {
            FrameConfirm::new(&self.id.pack(), &self.frame_id.pack())
        }
    }

    pub enum FrameOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Frame<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Frame<'a> {
        type Inner = Frame<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: unsafe { flatbuffers::Table::new(buf, loc) },
            }
        }
    }

    impl<'a> Frame<'a> {
        pub const VT_HEADER: flatbuffers::VOffsetT = 4;
        pub const VT_BYTES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Frame { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args FrameArgs<'args>,
        ) -> flatbuffers::WIPOffset<Frame<'bldr>> {
            let mut builder = FrameBuilder::new(_fbb);
            if let Some(x) = args.bytes {
                builder.add_bytes(x);
            }
            if let Some(x) = args.header {
                builder.add_header(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> FrameT {
            let header = self.header().map(|x| x.unpack());
            let bytes = self.bytes().map(|x| x.into_iter().collect());
            FrameT { header, bytes }
        }

        #[inline]
        pub fn header(&self) -> Option<&'a Header> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Header>(Frame::VT_HEADER, None) }
        }
        #[inline]
        pub fn bytes(&self) -> Option<flatbuffers::Vector<'a, i8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(Frame::VT_BYTES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Frame<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Header>("header", Self::VT_HEADER, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>("bytes", Self::VT_BYTES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FrameArgs<'a> {
        pub header: Option<&'a Header>,
        pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
    }
    impl<'a> Default for FrameArgs<'a> {
        #[inline]
        fn default() -> Self {
            FrameArgs { header: None, bytes: None }
        }
    }

    pub struct FrameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FrameBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_header(&mut self, header: &Header) {
            self.fbb_.push_slot_always::<&Header>(Frame::VT_HEADER, header);
        }
        #[inline]
        pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_BYTES, bytes);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FrameBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            FrameBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Frame<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Frame<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Frame");
            ds.field("header", &self.header());
            ds.field("bytes", &self.bytes());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct FrameT {
        pub header: Option<HeaderT>,
        pub bytes: Option<Vec<i8>>,
    }
    impl Default for FrameT {
        fn default() -> Self {
            Self { header: None, bytes: None }
        }
    }
    impl FrameT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> flatbuffers::WIPOffset<Frame<'b>> {
            let header_tmp = self.header.as_ref().map(|x| x.pack());
            let header = header_tmp.as_ref();
            let bytes = self.bytes.as_ref().map(|x| _fbb.create_vector(x));
            Frame::create(_fbb, &FrameArgs { header, bytes })
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Frame`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_frame_unchecked`.
    pub fn root_as_frame(buf: &[u8]) -> Result<Frame, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Frame>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Frame` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_frame_unchecked`.
    pub fn size_prefixed_root_as_frame(buf: &[u8]) -> Result<Frame, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Frame>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Frame` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_frame_unchecked`.
    pub fn root_as_frame_with_opts<'b, 'o>(opts: &'o flatbuffers::VerifierOptions, buf: &'b [u8]) -> Result<Frame<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Frame<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Frame` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_frame_unchecked`.
    pub fn size_prefixed_root_as_frame_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Frame<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Frame<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Frame and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Frame`.
    pub unsafe fn root_as_frame_unchecked(buf: &[u8]) -> Frame {
        unsafe { flatbuffers::root_unchecked::<Frame>(buf) }
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Frame and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Frame`.
    pub unsafe fn size_prefixed_root_as_frame_unchecked(buf: &[u8]) -> Frame {
        unsafe { flatbuffers::size_prefixed_root_unchecked::<Frame>(buf) }
    }
    #[inline]
    pub fn finish_frame_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Frame<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_frame_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Frame<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod base
