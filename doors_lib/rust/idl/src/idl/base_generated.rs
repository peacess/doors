// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::{cmp::Ordering, mem};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod base {

    use core::{cmp::Ordering, mem};

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    // struct UByte8, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct UByte8(pub [u8; 8]);
    impl Default for UByte8 {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for UByte8 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("UByte8")
                .field("ub1", &self.ub1())
                .field("ub2", &self.ub2())
                .field("ub3", &self.ub3())
                .field("ub4", &self.ub4())
                .field("ub5", &self.ub5())
                .field("ub6", &self.ub6())
                .field("ub7", &self.ub7())
                .field("ub8", &self.ub8())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UByte8 {}
    impl<'a> flatbuffers::Follow<'a> for UByte8 {
        type Inner = &'a UByte8;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a UByte8>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a UByte8 {
        type Inner = &'a UByte8;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<UByte8>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for UByte8 {
        type Output = UByte8;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const UByte8 as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for UByte8 {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> UByte8 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(ub1: u8, ub2: u8, ub3: u8, ub4: u8, ub5: u8, ub6: u8, ub7: u8, ub8: u8) -> Self {
            let mut s = Self([0; 8]);
            s.set_ub1(ub1);
            s.set_ub2(ub2);
            s.set_ub3(ub3);
            s.set_ub4(ub4);
            s.set_ub5(ub5);
            s.set_ub6(ub6);
            s.set_ub7(ub7);
            s.set_ub8(ub8);
            s
        }

        pub fn ub1(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub1(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub2(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[1..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub2(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[1..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub3(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[2..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub3(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[2..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub4(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[3..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub4(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[3..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub5(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub5(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub6(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[5..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub6(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[5..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub7(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[6..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub7(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[6..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub8(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[7..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub8(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[7..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct UByte16, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct UByte16(pub [u8; 16]);
    impl Default for UByte16 {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for UByte16 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("UByte16")
                .field("ub1", &self.ub1())
                .field("ub2", &self.ub2())
                .field("ub3", &self.ub3())
                .field("ub4", &self.ub4())
                .field("ub5", &self.ub5())
                .field("ub6", &self.ub6())
                .field("ub7", &self.ub7())
                .field("ub8", &self.ub8())
                .field("ub9", &self.ub9())
                .field("ub10", &self.ub10())
                .field("ub11", &self.ub11())
                .field("ub12", &self.ub12())
                .field("ub13", &self.ub13())
                .field("ub14", &self.ub14())
                .field("ub15", &self.ub15())
                .field("ub16", &self.ub16())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UByte16 {}
    impl<'a> flatbuffers::Follow<'a> for UByte16 {
        type Inner = &'a UByte16;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a UByte16>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a UByte16 {
        type Inner = &'a UByte16;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<UByte16>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for UByte16 {
        type Output = UByte16;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const UByte16 as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for UByte16 {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> UByte16 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(
            ub1: u8,
            ub2: u8,
            ub3: u8,
            ub4: u8,
            ub5: u8,
            ub6: u8,
            ub7: u8,
            ub8: u8,
            ub9: u8,
            ub10: u8,
            ub11: u8,
            ub12: u8,
            ub13: u8,
            ub14: u8,
            ub15: u8,
            ub16: u8,
        ) -> Self {
            let mut s = Self([0; 16]);
            s.set_ub1(ub1);
            s.set_ub2(ub2);
            s.set_ub3(ub3);
            s.set_ub4(ub4);
            s.set_ub5(ub5);
            s.set_ub6(ub6);
            s.set_ub7(ub7);
            s.set_ub8(ub8);
            s.set_ub9(ub9);
            s.set_ub10(ub10);
            s.set_ub11(ub11);
            s.set_ub12(ub12);
            s.set_ub13(ub13);
            s.set_ub14(ub14);
            s.set_ub15(ub15);
            s.set_ub16(ub16);
            s
        }

        pub fn ub1(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub1(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub2(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[1..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub2(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[1..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub3(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[2..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub3(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[2..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub4(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[3..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub4(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[3..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub5(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub5(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub6(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[5..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub6(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[5..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub7(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[6..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub7(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[6..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub8(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[7..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub8(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[7..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub9(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub9(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub10(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[9..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub10(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[9..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub11(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[10..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub11(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[10..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub12(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[11..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub12(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[11..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub13(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[12..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub13(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[12..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub14(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[13..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub14(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[13..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub15(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[14..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub15(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[14..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ub16(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[15..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ub16(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[15..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct UlidBytes, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct UlidBytes(pub [u8; 16]);
    impl Default for UlidBytes {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for UlidBytes {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("UlidBytes")
                .field("ts1", &self.ts1())
                .field("ts2", &self.ts2())
                .field("ts3", &self.ts3())
                .field("ts4", &self.ts4())
                .field("ts5", &self.ts5())
                .field("ts6", &self.ts6())
                .field("rand7", &self.rand7())
                .field("rand8", &self.rand8())
                .field("rand9", &self.rand9())
                .field("rand10", &self.rand10())
                .field("rand11", &self.rand11())
                .field("rand12", &self.rand12())
                .field("rand13", &self.rand13())
                .field("rand14", &self.rand14())
                .field("rand15", &self.rand15())
                .field("rand16", &self.rand16())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UlidBytes {}
    impl<'a> flatbuffers::Follow<'a> for UlidBytes {
        type Inner = &'a UlidBytes;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a UlidBytes>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a UlidBytes {
        type Inner = &'a UlidBytes;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<UlidBytes>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for UlidBytes {
        type Output = UlidBytes;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const UlidBytes as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for UlidBytes {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> UlidBytes {
        #[allow(clippy::too_many_arguments)]
        pub fn new(
            ts1: u8,
            ts2: u8,
            ts3: u8,
            ts4: u8,
            ts5: u8,
            ts6: u8,
            rand7: u8,
            rand8: u8,
            rand9: u8,
            rand10: u8,
            rand11: u8,
            rand12: u8,
            rand13: u8,
            rand14: u8,
            rand15: u8,
            rand16: u8,
        ) -> Self {
            let mut s = Self([0; 16]);
            s.set_ts1(ts1);
            s.set_ts2(ts2);
            s.set_ts3(ts3);
            s.set_ts4(ts4);
            s.set_ts5(ts5);
            s.set_ts6(ts6);
            s.set_rand7(rand7);
            s.set_rand8(rand8);
            s.set_rand9(rand9);
            s.set_rand10(rand10);
            s.set_rand11(rand11);
            s.set_rand12(rand12);
            s.set_rand13(rand13);
            s.set_rand14(rand14);
            s.set_rand15(rand15);
            s.set_rand16(rand16);
            s
        }

        pub fn ts1(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ts1(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ts2(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[1..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ts2(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[1..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ts3(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[2..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ts3(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[2..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ts4(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[3..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ts4(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[3..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ts5(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ts5(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn ts6(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[5..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ts6(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[5..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand7(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[6..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand7(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[6..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand8(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[7..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand8(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[7..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand9(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand9(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand10(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[9..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand10(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[9..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand11(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[10..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand11(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[10..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand12(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[11..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand12(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[11..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand13(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[12..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand13(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[12..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand14(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[13..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand14(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[13..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand15(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[14..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand15(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[14..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rand16(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[15..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rand16(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[15..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct Uint128, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Uint128(pub [u8; 16]);
    impl Default for Uint128 {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for Uint128 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Uint128").field("low", &self.low()).field("high", &self.high()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Uint128 {}
    impl<'a> flatbuffers::Follow<'a> for Uint128 {
        type Inner = &'a Uint128;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Uint128>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Uint128 {
        type Inner = &'a Uint128;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Uint128>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Uint128 {
        type Output = Uint128;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const Uint128 as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for Uint128 {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Uint128 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(low: u64, high: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_low(low);
            s.set_high(high);
            s
        }

        pub fn low(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_low(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn high(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_high(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct PartnerId, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct PartnerId(pub [u8; 16]);
    impl Default for PartnerId {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for PartnerId {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("PartnerId").field("low", &self.low()).field("high", &self.high()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for PartnerId {}
    impl<'a> flatbuffers::Follow<'a> for PartnerId {
        type Inner = &'a PartnerId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a PartnerId>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a PartnerId {
        type Inner = &'a PartnerId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<PartnerId>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for PartnerId {
        type Output = PartnerId;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const PartnerId as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for PartnerId {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> PartnerId {
        #[allow(clippy::too_many_arguments)]
        pub fn new(low: u64, high: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_low(low);
            s.set_high(high);
            s
        }

        pub fn low(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_low(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn high(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_high(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct TerminalId, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct TerminalId(pub [u8; 16]);
    impl Default for TerminalId {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for TerminalId {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("TerminalId").field("low", &self.low()).field("high", &self.high()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TerminalId {}
    impl<'a> flatbuffers::Follow<'a> for TerminalId {
        type Inner = &'a TerminalId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a TerminalId>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a TerminalId {
        type Inner = &'a TerminalId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<TerminalId>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for TerminalId {
        type Output = TerminalId;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const TerminalId as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for TerminalId {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> TerminalId {
        #[allow(clippy::too_many_arguments)]
        pub fn new(low: u64, high: u64) -> Self {
            let mut s = Self([0; 16]);
            s.set_low(low);
            s.set_high(high);
            s
        }

        pub fn low(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_low(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn high(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_high(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct Timestamp, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Timestamp(pub [u8; 8]);
    impl Default for Timestamp {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for Timestamp {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Timestamp").field("ts", &self.ts()).finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Timestamp {}
    impl<'a> flatbuffers::Follow<'a> for Timestamp {
        type Inner = &'a Timestamp;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Timestamp>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
        type Inner = &'a Timestamp;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Timestamp {
        type Output = Timestamp;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const Timestamp as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for Timestamp {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Timestamp {
        #[allow(clippy::too_many_arguments)]
        pub fn new(ts: i64) -> Self {
            let mut s = Self([0; 8]);
            s.set_ts(ts);
            s
        }

        pub fn ts(&self) -> i64 {
            let mut mem = core::mem::MaybeUninit::<<i64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<i64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_ts(&mut self, x: i64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<i64 as EndianScalar>::Scalar>(),
                );
            }
        }
    }

    // struct Header, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Header(pub [u8; 48]);
    impl Default for Header {
        fn default() -> Self {
            Self([0; 48])
        }
    }
    impl core::fmt::Debug for Header {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Header")
                .field("len", &self.len())
                .field("frame_type", &self.frame_type())
                .field("version", &self.version())
                .field("to_terminal_id", &self.to_terminal_id())
                .field("key", &self.key())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Header {}
    impl<'a> flatbuffers::Follow<'a> for Header {
        type Inner = &'a Header;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Header>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Header {
        type Inner = &'a Header;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Header>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Header {
        type Output = Header;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const Header as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(8)
        }
    }

    impl<'a> flatbuffers::Verifiable for Header {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Header {
        #[allow(clippy::too_many_arguments)]
        pub fn new(len: u64, frame_type: u32, version: u16, to_terminal_id: &TerminalId, key: &Uint128) -> Self {
            let mut s = Self([0; 48]);
            s.set_len(len);
            s.set_frame_type(frame_type);
            s.set_version(version);
            s.set_to_terminal_id(to_terminal_id);
            s.set_key(key);
            s
        }

        pub fn len(&self) -> u64 {
            let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_len(&mut self, x: u64) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn frame_type(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_frame_type(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn version(&self) -> u16 {
            let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[12..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_version(&mut self, x: u16) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[12..].as_mut_ptr(),
                    core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn to_terminal_id(&self) -> &TerminalId {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[16..].as_ptr() as *const TerminalId) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_to_terminal_id(&mut self, x: &TerminalId) {
            self.0[16..16 + 16].copy_from_slice(&x.0)
        }

        pub fn key(&self) -> &Uint128 {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[32..].as_ptr() as *const Uint128) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_key(&mut self, x: &Uint128) {
            self.0[32..32 + 16].copy_from_slice(&x.0)
        }
    }

    // struct FrameConfirm, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct FrameConfirm(pub [u8; 32]);
    impl Default for FrameConfirm {
        fn default() -> Self {
            Self([0; 32])
        }
    }
    impl core::fmt::Debug for FrameConfirm {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("FrameConfirm")
                .field("id", &self.id())
                .field("frame_id", &self.frame_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for FrameConfirm {}
    impl<'a> flatbuffers::Follow<'a> for FrameConfirm {
        type Inner = &'a FrameConfirm;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a FrameConfirm>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a FrameConfirm {
        type Inner = &'a FrameConfirm;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<FrameConfirm>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for FrameConfirm {
        type Output = FrameConfirm;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(self as *const FrameConfirm as *const u8, <Self as flatbuffers::Push>::size());
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for FrameConfirm {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> FrameConfirm {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: &UlidBytes, frame_id: &UlidBytes) -> Self {
            let mut s = Self([0; 32]);
            s.set_id(id);
            s.set_frame_id(frame_id);
            s
        }

        pub fn id(&self) -> &UlidBytes {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[0..].as_ptr() as *const UlidBytes) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_id(&mut self, x: &UlidBytes) {
            self.0[0..0 + 16].copy_from_slice(&x.0)
        }

        pub fn frame_id(&self) -> &UlidBytes {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[16..].as_ptr() as *const UlidBytes) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_frame_id(&mut self, x: &UlidBytes) {
            self.0[16..16 + 16].copy_from_slice(&x.0)
        }
    }

    pub enum FrameOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Frame<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Frame<'a> {
        type Inner = Frame<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Frame<'a> {
        pub const VT_HEADER: flatbuffers::VOffsetT = 4;
        pub const VT_BYTES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Frame { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args FrameArgs<'args>,
        ) -> flatbuffers::WIPOffset<Frame<'bldr>> {
            let mut builder = FrameBuilder::new(_fbb);
            if let Some(x) = args.bytes {
                builder.add_bytes(x);
            }
            if let Some(x) = args.header {
                builder.add_header(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn header(&self) -> Option<&'a Header> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Header>(Frame::VT_HEADER, None) }
        }
        #[inline]
        pub fn bytes(&self) -> Option<flatbuffers::Vector<'a, i8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(Frame::VT_BYTES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Frame<'_> {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Header>("header", Self::VT_HEADER, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>("bytes", Self::VT_BYTES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FrameArgs<'a> {
        pub header: Option<&'a Header>,
        pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
    }
    impl<'a> Default for FrameArgs<'a> {
        #[inline]
        fn default() -> Self {
            FrameArgs { header: None, bytes: None }
        }
    }

    pub struct FrameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FrameBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_header(&mut self, header: &Header) {
            self.fbb_.push_slot_always::<&Header>(Frame::VT_HEADER, header);
        }
        #[inline]
        pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_BYTES, bytes);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FrameBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            FrameBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Frame<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Frame<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Frame");
            ds.field("header", &self.header());
            ds.field("bytes", &self.bytes());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Frame`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_frame_unchecked`.
    pub fn root_as_frame(buf: &[u8]) -> Result<Frame, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Frame>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Frame` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_frame_unchecked`.
    pub fn size_prefixed_root_as_frame(buf: &[u8]) -> Result<Frame, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Frame>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Frame` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_frame_unchecked`.
    pub fn root_as_frame_with_opts<'b, 'o>(opts: &'o flatbuffers::VerifierOptions, buf: &'b [u8]) -> Result<Frame<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Frame<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Frame` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_frame_unchecked`.
    pub fn size_prefixed_root_as_frame_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Frame<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Frame<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Frame and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Frame`.
    pub unsafe fn root_as_frame_unchecked(buf: &[u8]) -> Frame {
        flatbuffers::root_unchecked::<Frame>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Frame and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Frame`.
    pub unsafe fn size_prefixed_root_as_frame_unchecked(buf: &[u8]) -> Frame {
        flatbuffers::size_prefixed_root_unchecked::<Frame>(buf)
    }
    #[inline]
    pub fn finish_frame_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Frame<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_frame_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Frame<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod base
