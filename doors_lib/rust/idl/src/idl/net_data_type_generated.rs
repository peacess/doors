// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::{cmp::Ordering, mem};

use crate::base_generated::*;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod net_data_type {

    use core::{cmp::Ordering, mem};

    use crate::base_generated::*;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
    pub const ENUM_MIN_HEADER_TYPE: u32 = 0;
    #[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
    pub const ENUM_MAX_HEADER_TYPE: u32 = 3;
    #[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_HEADER_TYPE: [HeaderType; 4] = [HeaderType::none, HeaderType::net_discovery, HeaderType::chat, HeaderType::ffi_rpc];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct HeaderType(pub u32);
    #[allow(non_upper_case_globals)]
    impl HeaderType {
        pub const none: Self = Self(0);
        pub const net_discovery: Self = Self(1);
        pub const chat: Self = Self(2);
        pub const ffi_rpc: Self = Self(3);

        pub const ENUM_MIN: u32 = 0;
        pub const ENUM_MAX: u32 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[Self::none, Self::net_discovery, Self::chat, Self::ffi_rpc];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::none => Some("none"),
                Self::net_discovery => Some("net_discovery"),
                Self::chat => Some("chat"),
                Self::ffi_rpc => Some("ffi_rpc"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for HeaderType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for HeaderType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = unsafe { flatbuffers::read_scalar_at::<u32>(buf, loc) };
            Self(b)
        }
    }

    impl flatbuffers::Push for HeaderType {
        type Output = HeaderType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            unsafe {
                flatbuffers::emplace_scalar::<u32>(dst, self.0);
            }
        }
    }

    impl flatbuffers::EndianScalar for HeaderType {
        type Scalar = u32;
        #[inline]
        fn to_little_endian(self) -> u32 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u32) -> Self {
            let b = u32::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for HeaderType {
        #[inline]
        fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u32::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for HeaderType {}
} // pub mod net_data_type
