
namespace base;
//
attribute FrameType;

// ulid,  ulid is big-endian, so can't use uint128 to store it directly. 
// the flatbuffers is little-endian（see, https://flatbuffers.dev/internals/）, if machine is big-endian, flatbuffers will auto convert the byte order when serialize/deserialize
struct UlidBytes{
    low: uint64;
    high: uint64;
}

struct UuidV7Bytes{
    low: uint64;
    high: uint64;
}

struct Ipv6{
    ub1: ubyte;
    ub2: ubyte;
    ub3: ubyte;
    ub4: ubyte;
    ub5: ubyte;
    ub6: ubyte;
    ub7: ubyte;
    ub8: ubyte;
    ub9: ubyte;
    ub10: ubyte;
    ub11: ubyte;
    ub12: ubyte;
    ub13: ubyte;
    ub14: ubyte;
    ub15: ubyte;
    ub16: ubyte;
}

struct X25519Public{
    key1: uint64;
    key2: uint64;
    key3: uint64;
    key4: uint64;
}

struct Uint128{
    low: uint64;
    high: uint64;
}

// like a user
struct PartnerId{
    low: uint64;
    high: uint64;
}

// a partner can run in many terminals
struct TerminalId{
    low: uint64;
    high: uint64;
}

struct Timestamp{
    ts: int64;
}

table Frame{
    header: Header;
    bytes: [byte];
}

struct Header{
    len:uint64;
    header_type: uint32;
    frame_type: uint32;
    to_terminal_id: TerminalId;
    key: base.X25519Public;
}

//确认收到
struct FrameConfirm(FrameType){
    //message id
    id: UlidBytes;
    // the frame id is confirmed
    frame_id: UlidBytes;
}

root_type Frame;
