
namespace base;
//
attribute FrameType;


enum HeaderType: uint32{
    none = 0,
    net_discovery = 1,
    chat = 2,
    ffi_rpc = 3,
    // error is a important mod in rust, add "_info" to avoid conflict
    error_info = 2147483647
}

// ulid,  ulid is big-endian, so can't use uint128 to store it directly.
// the flatbuffers is little-endian（see, https://flatbuffers.dev/internals/）, if machine is big-endian, flatbuffers will auto convert the byte order when serialize/deserialize
struct UlidBytes{
    low: uint64;
    high: uint64;
}

struct UuidV7Bytes{
    low: uint64;
    high: uint64;
}

struct Ipv6{
    ub1: ubyte;
    ub2: ubyte;
    ub3: ubyte;
    ub4: ubyte;
    ub5: ubyte;
    ub6: ubyte;
    ub7: ubyte;
    ub8: ubyte;
    ub9: ubyte;
    ub10: ubyte;
    ub11: ubyte;
    ub12: ubyte;
    ub13: ubyte;
    ub14: ubyte;
    ub15: ubyte;
    ub16: ubyte;
}

struct X25519Public{
    key1: uint64;
    key2: uint64;
    key3: uint64;
    key4: uint64;
}

struct Uint128{
    low: uint64;
    high: uint64;
}

// like a user
struct PartnerId{
    low: uint64;
    high: uint64;
}

// a partner can run in many terminals
struct TerminalId{
    low: uint64;
    high: uint64;
}

struct Timestamp{
    ts: int64;
}

table Frame{
    header: Header;
    bytes: [byte];
}

struct Header{
    // the total length of the frame, don't include the header length
    len:    uint32;
    header_type: uint32;
    frame_type: uint32;
    to_terminal_id: TerminalId;
    key: base.X25519Public;
}

//确认收到
struct FrameConfirm(FrameType){
    //message id
    id: UlidBytes;
    // the frame id is confirmed
    frame_id: UlidBytes;
}

table ErrorInfo{
    id: UlidBytes;
    req_id: UlidBytes;
    code: uint32;
    message: string;
}

table FrameError{
    header: Header;
    error_info: ErrorInfo;
}

root_type Frame;
