// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod idl {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FRAME_TYPE: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FRAME_TYPE: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FRAME_TYPE: [FrameType; 1] = [
  FrameType::Message,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FrameType(pub i16);
#[allow(non_upper_case_globals)]
impl FrameType {
  pub const Message: Self = Self(0);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 0;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Message,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Message => Some("Message"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for FrameType {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FrameType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i16>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for FrameType {
    type Output = FrameType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i16>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for FrameType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i16::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i16::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FrameType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FrameType {}
// struct Int128_64, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Int128_64(pub [u8; 16]);
impl Default for Int128_64 { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl std::fmt::Debug for Int128_64 {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Int128_64")
      .field("i1", &self.i1())
      .field("i2", &self.i2())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Int128_64 {}
impl flatbuffers::SafeSliceAccess for Int128_64 {}
impl<'a> flatbuffers::Follow<'a> for Int128_64 {
  type Inner = &'a Int128_64;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Int128_64>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Int128_64 {
  type Inner = &'a Int128_64;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Int128_64>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Int128_64 {
    type Output = Int128_64;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Int128_64 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Int128_64 {
    type Output = Int128_64;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Int128_64 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Int128_64 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Int128_64 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    i1: i64,
    i2: i64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_i1(i1);
    s.set_i2(i2);
    s
  }

  pub fn i1(&self) -> i64 {
    let mut mem = core::mem::MaybeUninit::<i64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i1(&mut self, x: i64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i64 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<i64>(),
      );
    }
  }

  pub fn i2(&self) -> i64 {
    let mut mem = core::mem::MaybeUninit::<i64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i2(&mut self, x: i64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i64 as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<i64>(),
      );
    }
  }

}

// struct Int128_32, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Int128_32(pub [u8; 16]);
impl Default for Int128_32 { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl std::fmt::Debug for Int128_32 {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Int128_32")
      .field("i1", &self.i1())
      .field("i2", &self.i2())
      .field("i3", &self.i3())
      .field("i4", &self.i4())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Int128_32 {}
impl flatbuffers::SafeSliceAccess for Int128_32 {}
impl<'a> flatbuffers::Follow<'a> for Int128_32 {
  type Inner = &'a Int128_32;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Int128_32>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Int128_32 {
  type Inner = &'a Int128_32;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Int128_32>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Int128_32 {
    type Output = Int128_32;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Int128_32 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Int128_32 {
    type Output = Int128_32;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Int128_32 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Int128_32 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Int128_32 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    i1: i32,
    i2: i32,
    i3: i32,
    i4: i32,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_i1(i1);
    s.set_i2(i2);
    s.set_i3(i3);
    s.set_i4(i4);
    s
  }

  pub fn i1(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<i32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i1(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i32 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<i32>(),
      );
    }
  }

  pub fn i2(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<i32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i2(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i32 as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<i32>(),
      );
    }
  }

  pub fn i3(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<i32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i3(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i32 as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<i32>(),
      );
    }
  }

  pub fn i4(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<i32>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i32>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i4(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i32 as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<i32>(),
      );
    }
  }

}

// struct Int128_8, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Int128_8(pub [u8; 8]);
impl Default for Int128_8 { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl std::fmt::Debug for Int128_8 {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Int128_8")
      .field("i1", &self.i1())
      .field("i2", &self.i2())
      .field("i3", &self.i3())
      .field("i4", &self.i4())
      .field("i5", &self.i5())
      .field("i6", &self.i6())
      .field("i7", &self.i7())
      .field("i8_", &self.i8_())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Int128_8 {}
impl flatbuffers::SafeSliceAccess for Int128_8 {}
impl<'a> flatbuffers::Follow<'a> for Int128_8 {
  type Inner = &'a Int128_8;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Int128_8>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Int128_8 {
  type Inner = &'a Int128_8;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Int128_8>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Int128_8 {
    type Output = Int128_8;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Int128_8 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Int128_8 {
    type Output = Int128_8;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Int128_8 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Int128_8 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Int128_8 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    i1: i8,
    i2: i8,
    i3: i8,
    i4: i8,
    i5: i8,
    i6: i8,
    i7: i8,
    i8_: i8,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_i1(i1);
    s.set_i2(i2);
    s.set_i3(i3);
    s.set_i4(i4);
    s.set_i5(i5);
    s.set_i6(i6);
    s.set_i7(i7);
    s.set_i8_(i8_);
    s
  }

  pub fn i1(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i1(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

  pub fn i2(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[1..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i2(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[1..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

  pub fn i3(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i3(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

  pub fn i4(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[3..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i4(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[3..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

  pub fn i5(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i5(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

  pub fn i6(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[5..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i6(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[5..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

  pub fn i7(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[6..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i7(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[6..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

  pub fn i8_(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<i8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[7..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_i8_(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i8 as *const u8,
        self.0[7..].as_mut_ptr(),
        core::mem::size_of::<i8>(),
      );
    }
  }

}

// struct Timestamp, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Timestamp(pub [u8; 8]);
impl Default for Timestamp { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl std::fmt::Debug for Timestamp {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Timestamp")
      .field("ts", &self.ts())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Timestamp {}
impl flatbuffers::SafeSliceAccess for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Timestamp>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Timestamp {
    type Output = Timestamp;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Timestamp {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> Timestamp {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    ts: i64,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_ts(ts);
    s
  }

  pub fn ts(&self) -> i64 {
    let mut mem = core::mem::MaybeUninit::<i64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_ts(&mut self, x: i64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i64 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<i64>(),
      );
    }
  }

}

// struct MessageHeader, aligned to 2
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct MessageHeader(pub [u8; 18]);
impl Default for MessageHeader { 
  fn default() -> Self { 
    Self([0; 18])
  }
}
impl std::fmt::Debug for MessageHeader {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("MessageHeader")
      .field("version", &self.version())
      .field("to_id", &self.to_id())
      .field("from_id", &self.from_id())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageHeader {}
impl flatbuffers::SafeSliceAccess for MessageHeader {}
impl<'a> flatbuffers::Follow<'a> for MessageHeader {
  type Inner = &'a MessageHeader;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a MessageHeader>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a MessageHeader {
  type Inner = &'a MessageHeader;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<MessageHeader>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for MessageHeader {
    type Output = MessageHeader;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const MessageHeader as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b MessageHeader {
    type Output = MessageHeader;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const MessageHeader as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for MessageHeader {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}
impl<'a> MessageHeader {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    version: i16,
    to_id: &Int128_8,
    from_id: &Int128_8,
  ) -> Self {
    let mut s = Self([0; 18]);
    s.set_version(version);
    s.set_to_id(&to_id);
    s.set_from_id(&from_id);
    s
  }

  pub fn version(&self) -> i16 {
    let mut mem = core::mem::MaybeUninit::<i16>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<i16>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_version(&mut self, x: i16) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const i16 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<i16>(),
      );
    }
  }

  pub fn to_id(&self) -> &Int128_8 {
    unsafe { &*(self.0[2..].as_ptr() as *const Int128_8) }
  }

  pub fn set_to_id(&mut self, x: &Int128_8) {
    self.0[2..2+8].copy_from_slice(&x.0)
  }

  pub fn from_id(&self) -> &Int128_8 {
    unsafe { &*(self.0[10..].as_ptr() as *const Int128_8) }
  }

  pub fn set_from_id(&mut self, x: &Int128_8) {
    self.0[10..10+8].copy_from_slice(&x.0)
  }

}

pub enum FrameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Frame<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Frame<'a> {
    type Inner = Frame<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Frame<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Frame { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FrameArgs<'args>) -> flatbuffers::WIPOffset<Frame<'bldr>> {
      let mut builder = FrameBuilder::new(_fbb);
      if let Some(x) = args.bytes { builder.add_bytes(x); }
      builder.add_len(args.len);
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_LEN: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_BYTES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn len(&self) -> i32 {
    self._tab.get::<i32>(Frame::VT_LEN, Some(0)).unwrap()
  }
  #[inline]
  pub fn type_(&self) -> FrameType {
    self._tab.get::<FrameType>(Frame::VT_TYPE_, Some(FrameType::Message)).unwrap()
  }
  #[inline]
  pub fn bytes(&self) -> Option<&'a [i8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(Frame::VT_BYTES, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Frame<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>(&"len", Self::VT_LEN, false)?
     .visit_field::<FrameType>(&"type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(&"bytes", Self::VT_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct FrameArgs<'a> {
    pub len: i32,
    pub type_: FrameType,
    pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for FrameArgs<'a> {
    #[inline]
    fn default() -> Self {
        FrameArgs {
            len: 0,
            type_: FrameType::Message,
            bytes: None,
        }
    }
}
pub struct FrameBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FrameBuilder<'a, 'b> {
  #[inline]
  pub fn add_len(&mut self, len: i32) {
    self.fbb_.push_slot::<i32>(Frame::VT_LEN, len, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: FrameType) {
    self.fbb_.push_slot::<FrameType>(Frame::VT_TYPE_, type_, FrameType::Message);
  }
  #[inline]
  pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_BYTES, bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FrameBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FrameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Frame<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Frame<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Frame");
      ds.field("len", &self.len());
      ds.field("type_", &self.type_());
      ds.field("bytes", &self.bytes());
      ds.finish()
  }
}
pub enum MessageBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MessageBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MessageBody<'a> {
    type Inner = MessageBody<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MessageBody<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MessageBody { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageBodyArgs<'args>) -> flatbuffers::WIPOffset<MessageBody<'bldr>> {
      let mut builder = MessageBodyBuilder::new(_fbb);
      if let Some(x) = args.text { builder.add_text(x); }
      if let Some(x) = args.ts { builder.add_ts(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TS: flatbuffers::VOffsetT = 6;
    pub const VT_TEXT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> Option<&'a Int128_8> {
    self._tab.get::<Int128_8>(MessageBody::VT_ID, None)
  }
  #[inline]
  pub fn ts(&self) -> Option<&'a Timestamp> {
    self._tab.get::<Timestamp>(MessageBody::VT_TS, None)
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MessageBody::VT_TEXT, None)
  }
}

impl flatbuffers::Verifiable for MessageBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Int128_8>(&"id", Self::VT_ID, false)?
     .visit_field::<Timestamp>(&"ts", Self::VT_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text", Self::VT_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageBodyArgs<'a> {
    pub id: Option<&'a Int128_8>,
    pub ts: Option<&'a Timestamp>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MessageBodyArgs<'a> {
    #[inline]
    fn default() -> Self {
        MessageBodyArgs {
            id: None,
            ts: None,
            text: None,
        }
    }
}
pub struct MessageBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: &Int128_8) {
    self.fbb_.push_slot_always::<&Int128_8>(MessageBody::VT_ID, id);
  }
  #[inline]
  pub fn add_ts(&mut self, ts: &Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(MessageBody::VT_TS, ts);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageBody::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MessageBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MessageBody<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MessageBody");
      ds.field("id", &self.id());
      ds.field("ts", &self.ts());
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
    type Inner = Message<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Message<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Message { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageArgs<'args>) -> flatbuffers::WIPOffset<Message<'bldr>> {
      let mut builder = MessageBuilder::new(_fbb);
      if let Some(x) = args.body { builder.add_body(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_BODY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn header(&self) -> Option<&'a MessageHeader> {
    self._tab.get::<MessageHeader>(Message::VT_HEADER, None)
  }
  #[inline]
  pub fn body(&self) -> Option<MessageBody<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MessageBody>>(Message::VT_BODY, None)
  }
}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<MessageHeader>(&"header", Self::VT_HEADER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MessageBody>>(&"body", Self::VT_BODY, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs<'a> {
    pub header: Option<&'a MessageHeader>,
    pub body: Option<flatbuffers::WIPOffset<MessageBody<'a>>>,
}
impl<'a> Default for MessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        MessageArgs {
            header: None,
            body: None,
        }
    }
}
pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: &MessageHeader) {
    self.fbb_.push_slot_always::<&MessageHeader>(Message::VT_HEADER, header);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<MessageBody<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MessageBody>>(Message::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("header", &self.header());
      ds.field("body", &self.body());
      ds.finish()
  }
}
}  // pub mod idl

